/*
# LD : charge la valeur du 1er param dans le registre

# ST : stocke la valeur du registre vers le second paramètre.

# ADD : Additionne les 2 premiers registres, et met le résultat dans le 3eme.

# SUB : Soustrait les 2 premiers registres, et met le résultat dans le 3eme.

# AND : Applique un & (ET bit-a-bit) sur les 2 premiers registres, et met le
# résultat dans le 3eme.

# OR : Applique un OU (bit-a-bit) sur les 2 premiers registres, et met le
#résultat dans le troisième.

# XOR : Fait un OU exclusif bit a bit (c'est comme un OU normal, mais 1^1 = 0)

# ZJMP : saute a l'adresse si le carry est a 1.

# LDI : additionne les 2 premiers, traite ca comme une adresse, y lit une valeur
# de la taille d’un registre et la met dans le 3eme.

# STI  : additionne les 2 derniers, utilise cette somme comme une adresse ou
# sera copiee la valeur du 1er param

# FORK : Crée un nouveau processus, qui hérite des diﬀérents états de son père,
 # à part son PC, qui est mis à (PC + (1er paramètre % IDX_MOD)).

# LLD : similaire a ld sans la restriction de IDX_MOD (ici 512) (a confirmer)

# LLDI : Pareil que ldi, mais n’applique aucun modulo aux adresses.

# LFORK : Pareil qu’un fork sans modulo à l'adresse.

# AFF : affiche sur la sortie standard le char ASCII
*/
